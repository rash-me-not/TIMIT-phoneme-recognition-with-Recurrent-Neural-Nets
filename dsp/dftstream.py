'''
Created on Aug 24, 2017

@author: mroch
'''

import numpy as np
import scipy.signal as signal

# Add-ons    

""" librosa is used for computing Mel frequency scale. Installation:
            Anaconda:  conda install -c conda-forge librosa
            pip:  pip install librosa
                (or "pip -u install librosa" to install without admin privilege)
"""
from librosa.filters import mel
from librosa.core.time_frequency import mel_frequencies
   
     
class DFTStream:
    '''
    DFTStream - Transform a frame stream to various forms of spectra
    '''


    def __init__(self, frame_stream, specfmt="dB", mels_N=12):
        '''
        DFTStream(frame_stream, specfmt, mels_N)        
        Create a stream of discrete Fourier transform (DFT) frames using the
        specified sample frame stream. Only bins up to the Nyquist rate are
        returned in the stream Optional arguments:
        
        specfmt - DFT output:  
            "complex" - return complex DFT results
             "dB" [default] - return power spectrum 20log10(magnitude)
             "mag^2" - magnitude squared spectrum
             "Mel" - melodic scale
        mels_N - Number of Mel filters to use.  Only applicable when
            specfmt == "Mel".
        '''
        
        self.format_types = {"complex" : 0,
                             "mag^2" : 1,
                             "dB" : 2,
                             "Mel" : 3}
        self.framer = frame_stream
        self.frame_len = frame_stream.get_framelen_samples()
        try:
            self.format = self.format_types[specfmt]
        except KeyError:
            raise ValueError("Unknown specfmt {}.  Use one of [{}]".format(
                specfmt, ", ".join(self.format_types.keys())))
             
        # Number of frequency bins is the same as the number of bins in the
        # frame
        self.dft_bins = self.frame_len
        
        # Only bins up to the Nyquist rate are usable.  The DFT routine that
        # we are using will return up to and including the Nyuist (half bins
        # plus 1 if even)
        self.Nyquist_Hz = self.framer.get_Fs() / 2.0
        # We add 1.1 instead of 1, see numpy.around for details which 
        # np.round uses.
        self.bins_Nyquist = np.int(np.round((self.frame_len+1.1)/2.0))
                 
        self.window = signal.get_window("hamming", self.frame_len)        
        
        if self.format == self.format_types["Mel"]:
            # Construct Mel filters
            self.mel_filters = mel(self.framer.get_Fs(), 
                self.dft_bins, mels_N)
            # Center frequencies of the Mel filters in Hz
            # Returns two more than are actually used (0 Hz and Nyquist)
            self.bins_Hz = mel_frequencies(mels_N+2, 
                   fmin=0, fmax=self.Nyquist_Hz)
            self.bins_Hz = self.bins_Hz[1:-1]  # Remove ends
            self.bins_N = len(self.bins_Hz)
        else:
            self.bins_Hz = np.arange(self.bins_Nyquist) / self.bins_Nyquist * self.Nyquist_Hz      
            self.bins_N = self.bins_Hz.shape[0]
            
         
    def shape(self):
        "shape() - Return dimensions of tensor yielded by next()"
        return np.asarray([len(self.bins_N), 1])
    
    def size(self):
        "size() - number of elements in tensor generated by iterator"
        return np.asarray(np.product(self.shape()))
    
    def get_Hz(self):
        "get_Hz(Nyquist) - Return frequency bin labels"
        return self.bins_Hz
            
    def __iter__(self):
        "__iter__() Return iterator for stream"
        self.frame_it = iter(self.framer)
        return self
    
    def __next__(self):
        "__next__() Return next DFT frame"
        values = next(self.frame_it)

        # Apply window function to frames & compute DFT for real signals
        # rfft assume that the signal is real and only returns up to 
        # and including Nyquist,
        windowed = values * self.window
        complexspectrum = np.fft.rfft(windowed, self.dft_bins)
          
        if self.format == 0:
            result = complexspectrum
        else:
            # Result requires magnitude squared
            result = np.abs(complexspectrum) ** 2
            # Floor values to prevent negative inf when they are too small
            # We use the floor value proposed in the ETSI ES 201 108 v1.1.2 
            # 2000-04 specification:  log(1.9287e-22) = -50
            floor = 1.9287e-22
            result[np.where(result < floor)] = floor
            if self.format == 2:
                result = 10 * np.log10(result)
            else: 
                # Mel filtered
                result = 10 * np.log10(np.dot(self.mel_filters, result))
                
        # Return up to Nyquist
        return result
        
    def __len__(self):
        "len() - Number of tensors in stream"
        return len(self.framer)

        
        
        
    
        